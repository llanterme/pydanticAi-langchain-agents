"""
Trace viewer utility for logfire traces.

This script allows viewing and analyzing traces generated by the logfire
integration with the PydanticAI agent system.
"""

import argparse
import os
import json
from datetime import datetime, timedelta

import logfire
from dotenv import load_dotenv

from utils.app_logging import initialize_logfire


def parse_args() -> argparse.Namespace:
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(description="View and analyze logfire traces")
    
    parser.add_argument(
        "--trace-id",
        type=str,
        help="Specific trace ID to view",
        required=False,
    )
    
    parser.add_argument(
        "--hours",
        type=int,
        default=24,
        help="Number of hours to look back for traces",
        required=False,
    )
    
    parser.add_argument(
        "--agent",
        type=str,
        choices=["ResearchAgent", "ContentAgent", "ImageAgent"],
        help="Filter traces by agent type",
        required=False,
    )
    
    parser.add_argument(
        "--topic",
        type=str,
        help="Filter traces by topic substring",
        required=False,
    )
    
    parser.add_argument(
        "--format",
        type=str,
        choices=["summary", "detailed", "json"],
        default="summary",
        help="Output format",
        required=False,
    )
    
    return parser.parse_args()


def format_duration(duration_ms: float) -> str:
    """Format duration in milliseconds to a readable string."""
    if duration_ms < 1000:
        return f"{duration_ms:.2f}ms"
    elif duration_ms < 60000:
        return f"{duration_ms/1000:.2f}s"
    else:
        return f"{duration_ms/60000:.2f}m"


def display_trace_summary(trace: dict) -> None:
    """Display a summary of a single trace."""
    print("=" * 80)
    
    # Basic trace info
    trace_id = trace.get("id", "Unknown")
    service = trace.get("service_name", "Unknown")
    start_time = datetime.fromisoformat(trace.get("start_time", "").replace("Z", "+00:00"))
    
    print(f"Trace ID: {trace_id}")
    print(f"Service: {service}")
    print(f"Start Time: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
    
    # Get spans to calculate duration and count events
    spans = trace.get("spans", [])
    if spans:
        end_times = [span.get("end_time") for span in spans if span.get("end_time")]
        if end_times:
            end_time = datetime.fromisoformat(max(end_times).replace("Z", "+00:00"))
            duration = (end_time - start_time).total_seconds() * 1000  # milliseconds
            print(f"Duration: {format_duration(duration)}")
    
    # Count events by type
    agent_events = {}
    for span in spans:
        events = span.get("events", [])
        for event in events:
            attrs = event.get("attributes", {})
            agent_type = attrs.get("agent_type")
            event_type = attrs.get("event")
            
            if agent_type and event_type:
                key = f"{agent_type}_{event_type}"
                if key not in agent_events:
                    agent_events[key] = 0
                agent_events[key] += 1
    
    # Print summary of agent activities
    if agent_events:
        print("\nAgent Activities:")
        for key, count in agent_events.items():
            agent, event = key.split("_", 1)
            print(f"  - {agent}: {event} ({count} events)")
    
    # Extract workflow state progression if available
    workflow_events = [
        event for span in spans 
        for event in span.get("events", []) 
        if "workflow" in event.get("name", "").lower()
    ]
    
    if workflow_events:
        print("\nWorkflow Progression:")
        for event in workflow_events:
            event_name = event.get("name", "").replace("Workflow event: ", "")
            print(f"  - {event_name}")
    
    print("=" * 80)


def display_detailed_trace(trace: dict) -> None:
    """Display detailed information about a trace."""
    print("=" * 80)
    
    # Basic trace info
    trace_id = trace.get("id", "Unknown")
    service = trace.get("service_name", "Unknown")
    start_time = datetime.fromisoformat(trace.get("start_time", "").replace("Z", "+00:00"))
    
    print(f"Trace ID: {trace_id}")
    print(f"Service: {service}")
    print(f"Start Time: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
    
    # Process each span
    spans = trace.get("spans", [])
    for span in spans:
        span_name = span.get("name", "Unknown Span")
        span_start = datetime.fromisoformat(span.get("start_time", "").replace("Z", "+00:00"))
        
        if span.get("end_time"):
            span_end = datetime.fromisoformat(span.get("end_time").replace("Z", "+00:00"))
            span_duration = (span_end - span_start).total_seconds() * 1000
            print(f"\n[{span_name}] - {format_duration(span_duration)}")
        else:
            print(f"\n[{span_name}] - (incomplete)")
        
        # Process events in this span
        events = span.get("events", [])
        for event in events:
            event_time = datetime.fromisoformat(event.get("time", "").replace("Z", "+00:00"))
            event_name = event.get("name", "Unknown Event")
            attrs = event.get("attributes", {})
            
            # Format the time as offset from span start
            time_offset = (event_time - span_start).total_seconds() * 1000
            
            print(f"  +{format_duration(time_offset)}: {event_name}")
            
            # Print important attributes
            for key, value in attrs.items():
                if key in ["agent_type", "event", "platform", "tone", "topic", "phase"]:
                    if isinstance(value, dict):
                        print(f"    {key}: {json.dumps(value, indent=2)}")
                    else:
                        print(f"    {key}: {value}")
            
            # For completions, show timing
            if "elapsed_time_ms" in attrs:
                print(f"    Time: {format_duration(attrs['elapsed_time_ms'])}")
    
    print("=" * 80)


def main() -> int:
    """Main function to view and analyze traces."""
    # Load environment variables
    load_dotenv()
    
    # Initialize logfire for trace queries
    initialize_logfire()
    
    args = parse_args()
    
    try:
        # Query traces
        if args.trace_id:
            # Get specific trace by ID
            trace = logfire.get_trace(args.trace_id)
            traces = [trace] if trace else []
        else:
            # Query traces based on filters
            query_params = {}
            
            # Set time window
            start_time = datetime.now() - timedelta(hours=args.hours)
            query_params["start_time"] = start_time.isoformat()
            
            # Apply agent filter if specified
            if args.agent:
                query_params["agent_type"] = args.agent
                
            # Apply topic filter if specified
            if args.topic:
                query_params["topic"] = args.topic
            
            # Query traces
            traces = logfire.query_traces(**query_params)
        
        if not traces:
            print("No traces found matching the criteria.")
            return 0
        
        # Display traces based on format
        if args.format == "json":
            print(json.dumps(traces, indent=2))
        elif args.format == "detailed":
            for trace in traces:
                display_detailed_trace(trace)
        else:  # summary format
            print(f"Found {len(traces)} traces")
            for trace in traces:
                display_trace_summary(trace)
                
        return 0
    
    except Exception as e:
        print(f"Error viewing traces: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
